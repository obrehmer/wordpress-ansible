---
- name: Install wordpress blog
  hosts: all
  become: true
  gather_facts: true
  vars_files:
    - vault.yml
  vars:
    web: 80
    ssh_port: 22
    packages:
      - python3-pymysql
      - php8.3-cli
      - php8.3-fpm
      - php8.3-mysql
      - php8.3-opcache
      - php8.3-mbstring
      - php8.3-xml
      - php8.3-gd
      - php8.3-curl
      - php8.3-redis
      - mysql-server
      - apache2
      - curl
      - python3
      - iptables-persistent
      - apache2-utils
      - unzip
      - redis-server
    key_file: authorized_keys.vault
    cloudflare: true
    cloudflare_sources:
      - 173.245.48.0/20
      - 103.21.244.0/22
      - 103.22.200.0/22
      - 103.31.4.0/22
      - 141.101.64.0/18
      - 108.162.192.0/18
      - 190.93.240.0/20
      - 188.114.96.0/20
      - 197.234.240.0/22
      - 198.41.128.0/17
      - 162.158.0.0/15
      - 104.16.0.0/13
      - 104.24.0.0/14
      - 172.64.0.0/13
      - 131.0.72.0/22
    domain: example.com

  tasks:

    - name: Gather package facts
      ansible.builtin.package_facts:
        manager: auto

    - name: Set timezone
      timezone:
        name: Europe/Oslo

    - name: Set TERM environment variable
      copy:
        dest: /etc/profile.d/terminal.sh
        mode: '0644'
        content: |
          TERM=xterm
          export TERM

    - name: Update cache and install packages async
      apt:
        name: "{{ packages }}"
        state: present
        update_cache: true
      poll: 0
      register: apt_job
      notify: Reload Apache

    - name: Define allowed ports
      set_fact:
        allowed_ports: "{{ [ssh_port] }}"

    - name: Configure iptables rules for allowed ports
      iptables:
        chain: INPUT
        protocol: tcp
        destination_port: "{{ item }}"
        jump: ACCEPT
        action: insert
        rule_num: 1
        comment: Allow incoming traffic on specified ports only
      loop: "{{ allowed_ports }}"

    - name: Allow HTTP traffic only from Cloudflare IP ranges
      iptables:
        chain: INPUT
        protocol: tcp
        destination_port: "{{ web }}"
        source: "{{ item }}"
        jump: ACCEPT
        action: insert
        rule_num: 1
        comment: Allow HTTP (port 80) from Cloudflare only
      loop: "{{ cloudflare_sources }}"

    - name: Allow incoming traffic from localhost
      iptables:
        chain: INPUT
        protocol: all
        source: 127.0.0.1
        jump: ACCEPT
        action: insert
        comment: Allow incoming traffic from localhost

    - name: Allow established and related connections
      iptables:
        chain: INPUT
        ctstate: ESTABLISHED,RELATED
        jump: ACCEPT

    - name: Set default policy to drop all other incoming connections
      iptables:
        chain: INPUT
        policy: DROP

    - name: Get current saved iptables rules
      slurp:
        src: /etc/iptables/rules.v4
      register: saved_rules
      ignore_errors: true

    - name: Get current iptables rules from system
      changed_when: false
      command: iptables-save
      register: current_rules

    - name: Save iptables rules if changed
      copy:
        content: "{{ current_rules.stdout }}"
        dest: /etc/iptables/rules.v4
        owner: root
        group: root
        mode: '0644'
      when: saved_rules is not failed
      diff: true

    - name: Set kernel parameters for Redis (if installed)
      when: redis_installed is defined and redis_installed
      vars:
        redis_installed: "{{ 'redis-server' in ansible_facts.packages or 'redis' in ansible_facts.packages }}"
      block:

        - name: Set vm.overcommit_memory at runtime
          changed_when: false
          ansible.builtin.command: echo 1 > /proc/sys/vm/overcommit_memory

        - name: Set vm.swappiness at runtime
          changed_when: false
          ansible.builtin.command: echo 1 > /proc/sys/vm/swappiness

        - name: Disable Transparent Huge Pages (THP) at runtime
          changed_when: false
          ansible.builtin.command: echo never > /sys/kernel/mm/transparent_hugepage/enabled

        - name: Disable Transparent Huge Pages defrag at runtime
          changed_when: false
          ansible.builtin.command: echo never > /sys/kernel/mm/transparent_hugepage/defrag

        - name: Ensure vm.overcommit_memory is persisted in sysctl.conf
          ansible.builtin.lineinfile:
            path: /etc/sysctl.conf
            mode: '0644'
            regexp: '^vm.overcommit_memory'
            line: 'vm.overcommit_memory = 1'
            create: true

        - name: Ensure vm.swappiness is persisted in sysctl.conf
          ansible.builtin.lineinfile:
            path: /etc/sysctl.conf
            mode: '0644'
            regexp: '^vm.swappiness'
            line: 'vm.swappiness = 1'
            create: true

        - name: Reload sysctl settings
          ansible.builtin.command: sysctl -p
          changed_when: false

        - name: Create systemd service to persistently disable THP
          ansible.builtin.copy:
            dest: /etc/systemd/system/disable-thp.service
            mode: '0644'
            content: |
              [Unit]
              Description=Disable Transparent Huge Pages (THP)
              DefaultDependencies=no
              After=sysinit.target local-fs.target
              Before=basic.target

              [Service]
              Type=oneshot
              ExecStart=/bin/sh -c "echo never > /sys/kernel/mm/transparent_hugepage/enabled"
              ExecStart=/bin/sh -c "echo never > /sys/kernel/mm/transparent_hugepage/defrag"
              RemainAfterExit=true

              [Install]
              WantedBy=multi-user.target

        - name: Enable and start disable-thp.service
          ansible.builtin.systemd:
            name: disable-thp.service
            enabled: true
            state: started



    # Apache Configuration
    - name: Write Apache VirtualHost configuration for {{ domain }}
      copy:
        dest: /etc/apache2/sites-available/{{ domain }}.conf
        mode: '0644'
        content: |
          <VirtualHost *:80>
              ServerName {{ domain }}
              DocumentRoot /var/www/{{ domain }}

              <Directory /var/www/{{ domain }}>
                  Options Indexes FollowSymLinks
                  AllowOverride All
                  Require all granted
              </Directory>

              <FilesMatch \.php$>
                  SetHandler "proxy:unix:/run/php/php8.3-fpm.sock|fcgi://localhost/"
              </FilesMatch>

              ErrorLog ${APACHE_LOG_DIR}/{{ domain }}_error.log
              CustomLog ${APACHE_LOG_DIR}/{{ domain }}_access.log combined
          </VirtualHost>
      notify: Restart Apache


    - name: Enable site using a2ensite
      command: a2ensite {{ domain }}.conf
      args:
        creates: /etc/apache2/sites-enabled/{{ domain }}.conf
      notify: Restart Apache

    - name: Enable Apache
      systemd:
        name: apache2
        enabled: true
        state: started

    - name: Enable required Apache modules
      ansible.builtin.command: a2enmod {{ item }}
      args:
        creates: "/etc/apache2/mods-enabled/{{ item }}.load"
      loop:
        - proxy
        - proxy_fcgi
        - rewrite
        - headers
        - setenvif
      notify: Restart Apache


    - name: Enable mysql
      systemd:
        name: mysql
        enabled: true
        state: started

    - name: Enable fpm
      systemd:
        name: php8.3-fpm
        enabled: true
        state: started

    - name: Create WordPress MySQL database
      mysql_db:
        name: "{{ database }}"
        state: present
        encoding: utf8mb4
        collation: utf8mb4_general_ci
        login_user: root
        login_unix_socket: /var/run/mysqld/mysqld.sock

    - name: Create WordPress MySQL user
      mysql_user:
        name: "{{ mysqluser }}"
        password: "{{ mysqlpass }}"
        host: localhost
        priv: "{{ database }}.*:ALL"
        state: present
        login_user: root
        login_unix_socket: /var/run/mysqld/mysqld.sock

    - name: Flush MySQL privileges (optional, mysql_user usually does it)
      mysql_user:
        name: WordPressUser
        host: localhost
        check_implicit_admin: true
        state: present
        login_user: root
        login_unix_socket: /var/run/mysqld/mysqld.sock

    - name: Download latest WordPress
      changed_when: false
      get_url:
        path: https://wordpress.org/latest.zip
        dest: /tmp/latest.zip
        mode: '0644'

    - name: Unarchive WordPress to temporary location
      unarchive:
        src: /tmp/latest.zip
        dest: /tmp/
        remote_src: true

    - name: Move WordPress files to web root
      command: mv /tmp/wordpress /var/www/{{ domain }}
      args:
        creates: /var/www/{{ domain }}/wp-config-sample.php

    - name: Ensure correct ownership
      file:
        path: /var/www/{{ domain }}
        state: directory
        recurse: true
        owner: www-data
        group: www-data

    - name: Remove temporary WordPress zip
      file:
        path: /tmp/latest.zip
        state: absent

    - name: Remove temporary WordPress unzipped directory
      file:
        path: /tmp/wordpress
        state: absent

    - name: Create backup dir
      file:
        path: /backup/{{ domain }}/mysql/
        state: directory
        owner: root
        group: root
        mode: '0755'
        recurse: true

    - name: MySQL-Dump-Skript
      copy:
        dest: /usr/local/bin/mysql_backup_{{ domain }}.sh
        mode: '0755'
        owner: root
        group: root
        content: |
          #!/bin/bash
          BACKUP_DIR="/backup/{{ domain }}/mysql"
          DATE=$(date +%F)
          DUMP_FILE="${BACKUP_DIR}/db-${DATE}.sql.gz"

          mysqldump --defaults-extra-file=/etc/mysql/debian.cnf --all-databases | gzip > "$DUMP_FILE"

          find "$BACKUP_DIR" -type f -name "db-*.sql.gz" -mtime +10 -delete

    - name: Cronjob  MySQL-Dump
      cron:
        name: " MySQL-Dump {{ domain }}"
        user: root
        job: "/usr/local/bin/mysql_backup_{{ domain }}.sh"
        minute: 30
        hour: 2

  handlers:

    - name: Reload systemd daemon
      systemd:
        daemon_reload: true

    - name: Restart Apache
      service:
        name: apache2
        state: restarted

    - name: Reload Apache
      service:
        name: apache2
        state: reloaded

    - name: Restart mysql
      service:
        name: mysql
        state: restarted
